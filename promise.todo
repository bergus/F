/* OPEN ISSUES
* if a promise is already fulfilled, you can add on*-Handlers which will never be called
	obviously wrong
** call handlers when adding them to fulfilled promises? What about restartables then?
	nothing is restartable
** public getState function?
	-> synchronous inspection
* What happens to a stopped multiple promise, which gets started with a new parameter?
	save arguments
* multiple promises getting ended with different types while beeing stopped are not correctly restarted!
* conventions for errors: Must be multiple callback?
* dann-Promises have no chance to receive messages from wenn. Any need for that?
	no. bubble-up.
* implement a get(prop) function. ridicoulus approach?
	-> Functor
* abort dann in error case / abort sonst in success case ???
			// wenn.onError(dann.abort) ???
			// wenn.onSuccess(sonst.abort) ???
* .then(function(r, s){ [...]; s(x, y, z)}).then(fn) == .then(function(r){ [...]; return fn(x, y, z);})
	-> Composition law of Functors
* function x(p){return Promise.prompt(p);}); x("").then(x) // Endlosschleife!
* 
*/


// 3 Promise-Funktionen sind wichtig und beschreibbar:
// * chain / Verkettung -> Nacheinander, mit Option was ein Error (jeglicher Art) auslösen soll (returnError | nextPromise | defaultError (spezialError) -> Kontinue after Error ...)
// * merge / Vereinigung -> Parallelität, mit Option ob All-/Existenzquantor für Error-/Success-return gilt
// * endlicher Automat: -> Menge der Zustände (mit Start- und Endzustand), Ablaufrelationen, defaultSuccess, defaultError
	a Promise to be fulfilled when the final state is reached
	implements a full finite-state-machine

// message-Konzept ausarbeiten (Kettendurchlauf?)
// Start-Stop-Konzept ausarbeiten
// insbesondere bei Verzweigungen nur eigene Zweige anhalten? Implementation im endlichen Automaten?

----

// Think of a (naive?) promise loop:
Promise.until = function(cond, fn, value) {
	if (cond(value)) return Promise.of(value); // for while: if (!cond(value)) …
	return fn(value).chain(Promise.until.bind(Promise, cond, fn));
};
// (example usage)
Promise.until(function(x) { return x > 9 }, function(x) {
	console.log(x);
	return Promise.timeout(100, x).chain(function(y) {
		console.log("timed "+y);
		return y+1;
	});
}, 0).map(function(x){console.log(x, "done"); debugger; });
// which would unfold to something like
var x= Promise.of(0).chain(function(x) {
 return Promise.of(1).chain(function(x) {
  return Promise.of(2).chain(function(x) {
   return Promise.of(3).chain(function(x) {
    return Promise.of(4).chain(function(x) {
     return Promise.of(5).chain(function(x) {
      return Promise.of(6).chain(function(x) {
       return Promise.of(7).chain(function(x) {
        return Promise.of(8).chain(function(x) {
         return Promise.of(9);
        });
       });
      });
     });
    });
   });
  });
 });
});
x.map(console.log);

/* How can we deal with this efficiently?
[X] above unfolded `chain` call can execute all callbacks synchronously
[ ] when executing `chain` callbacks, don't have them schedule their continuations
[?] the innermost promise resolution needs to resolve n promises
[X] when resolving the innermost promise, prevent a stack overflow
[?] the innermost promise resolution doesn't execute n callbacks
[X] the innermost promise resolution doesn't need n function calls until the outermost registered callbacks (console.log)
FAIL after the promise is resolved, adding a new callback doesn't lead to a stack overflow

*/
----

var t1 = Promise.of("1"),
    t2 = Promise.of("2");
var t3 = t1.map(function(a) { console.log(a); return "3";});
Promise.all([t1, t2, t3]).map(console.log);