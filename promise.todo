/* Cancellation (https://github.com/promises-aplus/cancellation-spec)
* .canceled=true property on errors (https://github.com/promises-aplus/cancellation-spec/issues/1#issuecomment-11452893)
* rejection or not? (https://github.com/promises-aplus/cancellation-spec/issues/1#issuecomment-11624303)
* .catchCancelation / .handleCancellation
* CancellationException instanceof Error, .name = 'OperationCancelled', .cancelled = true, .reason & .data (https://github.com/promises-aplus/cancellation-spec/issues/2)
* .abort() is .cancel() without propagation
* Cancellation should only need to be considered by the PromiseLibraries/Implementations, the person actually initiating/using cancellation and the person managing the underlying IO operation. (https://github.com/promises-aplus/cancellation-spec/issues/3#issuecomment-11708125)
* can't decide between cancelled and canceled https://github.com/promises-aplus/cancellation-spec/issues/4
* .uncancellable() https://github.com/promises-aplus/cancellation-spec/issues/6
* Returns the rejection reason if the deferred was canceled normally. If the second, optional "strict" argument is true means it will throw an error if the promise is fulfilled. http://dojotoolkit.org/reference-guide/1.10/dojo/Deferred.html#cancel
* derived = fulfilledPromise.then(function doSomething(){return childPromise}); derived.cancel(); - derived is cancelled and doSomething is executed, but what about childPromise? (https://github.com/promises-aplus/cancellation-spec/issues/7#issuecomment-17761795)
*/

// test snippet for cancellation:
var a = Promise.defer(500, "hello").chain(function(x){console.log(x); return Promise.defer(500, "delays");}).map(console.log)
setTimeout(function(){ a.cancel(); }, 550)
Promise.run(a.fork(null, function(e) { console.log(e.stacktrace);}))


/* OPEN ISSUES
* if a promise is already fulfilled, you can add on*-Handlers which will never be called
	obviously wrong
** call handlers when adding them to fulfilled promises? What about restartables then?
	nothing is restartable
** public getState function?
	needed
* What happens to a stopped multiple promise, which gets started with a new parameter?
	save arguments
* multiple promises getting ended with different types while beeing stopped are not correctly restarted!
* promises can get ended with different types whiel beeing stopped !!! (used for Stream)
* conventions for errors: Must be multiple callback?
* dann-Promises have no chance to receive messages from wenn. Any need for that?
	no. bubble-up.
* implement a get(prop) function. ridicoulus approach?
	tbd
* abort dann in error case / abort sonst in success case ???
			// wenn.onError(dann.abort) ???
			// wenn.onSuccess(sonst.abort) ???
* .then(function(r, s){ [...]; s(x, y, z)}).then(fn) == .then(function(r){ [...]; return fn(x, y, z);})
* .syncThen(function(a, b,c){ return [...no error...]}) == .filter(function([a, b, c]){ return [Array]})
* var x = new Promise(function(p){return prompt(p);}); x.then(x).start("Endlosschleife!");

* What happens when an error handler handles a CancellationError? Would the error handler be executed, but ignored?
  Would the resulting promise resolve as normal, and could (need to) be cancelled a second time?
  Do CancellationErrors need to be propagated at all, or are the promises in the chain already rejected by the cancellation itself?
* What happens to a success handler (or its result) on a fulfilled promise that is cancelled before the handler returns?
	unlikely: the cancellation happens either in the gap between fulfilling the promise and executing the handlers async,
	          or is issued from the handler itself (which might better `throw` a `new CancellationError`, but that's not necessarily the same)
	regardless: the handler should be executed, and its result value should be immediately cancelled
* a `send()` call currently recursively descends down the whole chain until it finds a promise that does not respond to it
	no single resolved promise should respond to a `send()` call
*/

/* IDEAS
* TODO: make all runners (local-)stateless, to avoid problems with recursive reentry, or after abrupt completions
  The first might happen (...when you expect it the least :-) in similar cases as ValueStream::valueOf()
  The second would allow to finish off the remaining continuations in a manner as
  	Promise.run = function(cont) {
  		try {
  			while(typeof cont=="function")cont=cont()//as usual
  		} catch(e) {
  			console.error(e);
  			Promise.run(cont);
  		}
  	}
  But that's probably a bad idea anyway, given that the offending continuation might just get re-executed by this
* unhandled rejections: issue a warning in the handler-runner of rejected promises in case there are no handlers
* In the runner(s): prevent endless loops - they don't overflow the stack!
  TODO: Prevent self-resolving promises, and possibly even mutually-dependent ones
* In the runner(s): keep a list of the continuations that ran in the loop
  and make it available (to unhandled warnings, or `then` stacktraces) for debugging purposes
  however I am a little unsure how to get information about user code involved in it
  likely to be interesting are stack traces from the creation of Promise objects, not the about the many callbacks that were executed
* bind message to Promise.run from which async action the continuations are ran, and where the call to this task was issued
* a PendingPromise constructor that eats all handlers (for breakfast)
* asynchronous continuations (probably not a so good idea):
  every line of control flow is run by its own, async runner (that keeps track of the "stack")
  this includes cancellation any async action, with the "simple" `return`syntax for the specific canceller
  only a bit unsure how forked flow works - but it might be an interesting concept for "stop/go":
                                            everyone with access to the line can make it go, or abandon it

*/

/* SPEC: Communication
Rationale: We want to communicate with unresolved promises. Duplex. Interoperable.

We do not care about resolved promises. They represent the result of a task that has been completed.
Any values that are received by the means of the following methods are supposed to be disposed when the promise is resolved, to prevent memory leaks.

* Progress
`onprogress` IS [supposed to be] the third argument to a `.then()` call. It MUST (as soon as possible???) be passed as the third argument to any `.then()` call on every pending promise that the resulting promise depends upon.
These especially include the original promise that `.then()` was called on and the child promises that possible handlers might have returned, but the concept applies to all other promise combinators that a library might offer.
The value of the `onprogress` parameter MIGHT be a function (and MUST have a `.call()` method???). It SHOULD (must???) never be called after a promise has been resolved (see rationale).
What values exactly are passed through, and how to interact with them, is not part of this specification; though there is a recommendation for function handlers below.
OPEN: What happens in case of multiple `then()` calls on one promise? Allow event duplication (with child handler calls), or do we require pass-through of the handlers themselves?

* Send
Every promise MUST have a `send()` method. When called, it MUST invoke the `.send()` methods on all pending promises that it depends on with the exact same arguments. It MUST `return` the result of such a call, or an array of the results of multiple calls. 
If a promise is resolved, a `.send()` call SHOULD (must???) be a noop, and MUST `return undefined`.
The structure of the arguments is not part of this specification, though there is a recommendation below.

* [NOTE] parameters
Both functions that are passed as `onprogress` handlers, and the `send` methods, serve as event channels between promise creators and consumers.
The first parameter should be a string with the name of the event, so that different communication purposes can be distinguished, and standards about how to handle specific ones can be devised.
The second parameter should, in case it is meant as an event object, have the value of the first parameter as its `.name` property.
OPEN: Should we fix the number of arguments for an efficient implemenation (to 2?), and use arrays when more are necessary?
A proposal cancellation implemented in terms of that can be found below.

*/



// 3 Promise-Funktionen sind wichtig und beschreibbar:
// * chain / Verkettung -> Nacheinander, mit Option was ein Error (jeglicher Art) auslösen soll (returnError | nextPromise | defaultError (spezialError) -> Kontinue after Error ...)
// * merge / Vereinigung -> Parallelität, mit Option ob All-/Existenzquantor für Error-/Success-return gilt
// * endlicher Automat: -> Menge der Zustände (mit Start- und Endzustand), Ablaufrelationen, defaultSuccess, defaultError
	a Promise to be fulfilled when the final state is reached
	implements a full finite-state-machine

// message-Konzept ausarbeiten (Kettendurchlauf?)
// Start-Stop-Konzept ausarbeiten
// insbesondere bei Verzweigungen nur eigene Zweige anhalten? Implementation im endlichen Automaten?

// Ein bestimmtes Promise ist bereits vorhanden. Was soll darufhin ausgeführt werden?
// * einfache Funktion - ohne Promise-Rückgabe  => onSuccess, onError, onFinal
// * synchrone "Filter"-Funktion - neues Promise | unstoppbar
// * synchroner Filter oder Funktion mit callback - neues Promise | möglichst stoppbar
// * synchroner Filter oder Rückgabe Promise - neues Promise | möglichst stoppbar
// * Funktion mit callback - neues Promise | stoppbar ?
// * weiteres Promise - neues Promise (Chain?) | auf alle Fälle stoppbar

/* TEST SCRIPT FOR STOP-GO PROMISES */
var ldebug = function(m) { var t = document.getElementById("IO"); t.value += "\n"+m; t.scrollTop = t.scrollHeight-t.clientHeight; };

var f = function f(p, s, e, m) {
 ldebug("getting "+[].join.call(p, ", "));
 var t = Number(p[0])*1000;
 setTimeout(function(){
  var r = Math.round(Math.random()*p[1]);
  ldebug("after "+t+"ms successing "+r+" of "+p[1]);  
  s(r, p[1]);
 }, t);
};
var p = new Promise(f).then(function endless(p){
 return new Promise(f).then(endless).arg(p);
});
p.onFinal(function(a, b){
 ldebug("after "+a+" seconds returning "+b);
});
var s = p.start(5, 10);
var time = setTimeout(function x(){
 ldebug(s.name || s);
 s = s();
 time = setTimeout(x, 4*1000);
}, 4*1000);
setTimeout(function(){
 p.stop(); clearTimeout(time);
 p.abort();
 ldebug(p);
}, 50*1000);
return "";

/* TEST SCRIPT FOR toString */
function nothing(){}
return "" + new Promise(nothing).then(nothing).cache(nothing).then(new Promise(nothing).then(nothing)).syncThen(nothing);

/* TEST SNIPPET FOR simple Promise */
return new Promise(function(p,s){window.setTimeout(function(){s("Hallo Welt");}, 500);});

/* TEST SNIPPET FOR updatable Promise */
return new Promise(function(p,s){var i=0;window.setInterval(function(){s("Hallo Welt "+ ++i)}, 500);}, {updatable:true});

/* TEST SNIPPET FOR multiple Promise */
var i=0, x = new Promise(function(p,s){
 window.setTimeout(function(){s("Hallo Welt "+ ++i)}, 500);
}, {updatable:true, starts:"multiple"});
x.onSuccess(function(){x.start();});
return x;

/* TEST SNIPPET FOR simple Stream */
return new Promise.Stream(function(p,s){
 var i=0;
 var t=window.setInterval(function(){s("Hallo Welt "+ ++i)}, 500);
 window.setTimeout(function(){window.clearInterval(t);s();},5000);
});